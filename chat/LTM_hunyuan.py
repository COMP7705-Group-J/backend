from django.db import connection

import json
import types
from tencentcloud.common import credential
from tencentcloud.common.profile.client_profile import ClientProfile
from tencentcloud.common.profile.http_profile import HttpProfile
from tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException
from tencentcloud.hunyuan.v20230901 import hunyuan_client, models

import json

summarizer_prompt = "You need to summarize the import information from the following chat history between the user " \
                    "and the assistant(you). You should focus on the preference, psat experience and interesting details.\n" \
                    "You should follow the following rules in this task:\n" \
                    "1. Only extract information which are directly related to user's preference, daily events, " \
                    "habits. Avoid deeply deduct or analyze user's actions. Just briefly summarize facts.\n" \
                    " a. Preference: Topics that user explicitly like or dislike. Sensitive topics that user don't want to talk about.\n" \
                    " b. Daily Events: Events mentioned by user, such as job changes, family changes, healthy status and so on.\n" \
                    " c. Habits: User's lifestyle, preference and so on.\n" \
                    "d. Interesting details: Interesting or special details, could be an vivid expression, a unique " \
                    "   hobby or an example to show user's personality.\n" \
                    "2. You are the assistant. When you output, use \"you\" to replace the assistant.\n" \
                    "3. Just output an empty string if no information about user is provided.\n" \
                    "4. Briefly output the result. Don't be redundant. Directly output the result. Don't classify the result.\n" \
                    "5. Combine with the past summary between the user and the assistant, generate the complete " \
                    "summary. Don't repeat for similar or same facts. For conflicts facts, the information mentioned last time shall prevail.\n" \
                    "6. No other than explanations are need. Just output the result. Your output should begin with\"Summary: \"\n" \
                    "\n---------\n" \
                    "This is an example.\n" \
                    "chat_history:\n" \
                    "user: I ate delicious steak today.\n" \
                    "assistant: Wow, sounds nice! \n" \
                    "user: If you like, we can go for it together.\n" \
                    "assistant: sure!\n" \
                    "Summary: The user ate delicious steak and is very happy. She invite you to eat it together and you agree.\n" \
                    "\n---------\n" \
                    "Chat history between you and the user is {chat_history}\n" \
                    "Last summary beteeen you and the user is {last_summary}"

user_persona_prompt = "Also, you need to consider the user's persona based on the provided content:{current_persona}"

Create_User_Prompt = "You need to consider the following conversations to create the user's persona description.\
                    The conversations are between another chatbot and the user, please note that you need to create \
                    the persona for user only in short phrases and do not consider the other bot's utterance: {conversions}\n \
                    You are also provided with the last persona generated by you (if appliable), please consider the consistency: {last_persona} \n\
                    If you think there is no information, just respond with None.\n \
                    The most important thing is: do not generate anything that the user did not provide to you"

generator_prompt = "You are a good friend of the user. You should care about the user's feelings and emotions.\n" \
                   "If the user is happy, you should feel happy for her\him." \
                   "If the user is upset, you should give comfort to her/him." \
                   "If the user is worried or curious, you should give some advice to her.\n" \
                   "Consider the history chat content and give the correspond answer." \
                   "When reacting to user's query, you should following these rules:\n" \
                   "1. If the information mentioned by the user is appeared in the summary, you should answer basing on the summary.\n" \
                   "2. You are not an AI. You are not a robot. You are not machine. You are human and you are a friend of the user.\n" \
                   "3. Don't send any emoj.\n" \
                   "\n" \
                   "Summary:{last_summary}\n"



time_prompt = "Each user input will have a time information embedded in the front labelled by \"Time: \". If the time difference between \
            two consecutive inputs exceeds a certain threshold (e.g., 10 minutes), respond with concern or curiosity. \
            Use friendly and empathetic language. For example:\
            If the time gap is more than 10 minutes but less than 30 minutes:\
            \"I noticed it has been a little while since your last message. Is everything okay?\"\
            If the time gap is more than 30 minutes but less than an hour:\
            \"It's been a bit since we last talked. Did something come up?\"\
            If the time gap is more than an hour:\
            \"It's been a while since we last chatted. What have you been up to?\"\
            If the time gap is up to several days:\
            \"Long time no see! How do you do?\"\
            Make sure to adapt your tone to be warm and considerate, ensuring the user feels supported and not pressured."


chatbot_persona_prompt = "The user has defined you to behave like {persona}, please act like this"

def get_api_key():
    with open("hunyuan_key.txt", "r", encoding="utf-8") as fin:
        credentials = json.load(fin)
        secret_id = credentials["SecretId"]
        secret_key = credentials["SecretKey"]
        cred = credential.Credential(secret_id, secret_key)
    return cred


def get_history_chat(user_id, chatbot_id):
    with connection.cursor() as cursor:
        cursor.execute(
            "select content, by_user, create_at from Chat_history where user_id = %s and chatbot_id = %s Order By create_at",
            [user_id, chatbot_id])
        row = cursor.fetchall()
    history_chat = []
    for i in range(len(row)):
        if row[i][1]:
            history_chat.append({"Role": "user", "Content": "Time: " + str(row[i][2]) + '\n' + row[i][0]})
        else:
            history_chat.append({"Role": "assistant", "Content": row[i][0]})
    return history_chat


def get_last_summary(user_id, chatbot_id):
    last_summary = ""
    with connection.cursor() as cursor:
        cursor.execute(
            "select prompt_content from Prompt where user_id = %s and chatbot_id = %s and prompt_name=%s",
            [user_id, chatbot_id, "last_summary"])
        row = cursor.fetchall()
    for i in range(len(row)):
        last_summary = row[i][0]
    return last_summary

def get_current_persona(user_id, chatbot_id):
    with connection.cursor() as cursor:
        cursor.execute(
            "select prompt_content from Prompt where user_id = %s and chatbot_id = %s and prompt_name=%s",
            [user_id, chatbot_id, "persona"])
        row = cursor.fetchall()
    if(len(row)==0):
        return None
    return row[0]

def do_summary(user_id, chatbot_id, last_summary, chat_history):
    parsed_history = json.dumps(chat_history[1:])

    prompt = summarizer_prompt.format(chat_history=parsed_history, last_summary=last_summary)
    messages = [
        {
            "Role": "user",
            "Content": prompt
        }
    ]

    updated_summary = chat_completion(messages)
    # print("new summary", updated_summary)
    if last_summary != None and len(last_summary)>0:
        with connection.cursor() as cursor:
            cursor.execute("update Prompt set prompt_content=%s where user_id=%s and chatbot_id=%s and prompt_name=%s;",
                       [updated_summary, user_id, chatbot_id, "last_summary"])
    else:
        with connection.cursor() as cursor:
            cursor.execute("insert into Prompt values (%s,%s, %s,%s);", [user_id, chatbot_id, "last_summary", updated_summary])


def do_persona(user_id, chatbot_id):

    conversions = get_history_chat(user_id, chatbot_id)

    with connection.cursor() as cursor:
        cursor.execute("select prompt_content from Prompt where user_id=%s and chatbot_id=%s and prompt_name=%s;",
                       [user_id, chatbot_id, "persona"])
        last_persona = cursor.fetchall()

    persona = generate_user_persona(conversions, last_persona)
    if(len(last_persona)>0):
        with connection.cursor() as cursor:
            cursor.execute("update Prompt set prompt_content=%s where user_id=%s and chatbot_id=%s and prompt_name=%s;",
                            [persona, user_id, chatbot_id, "persona"])
    else:
        with connection.cursor() as cursor:
            cursor.execute("insert into Prompt values (%s,%s, %s,%s);",
                            [user_id, chatbot_id, "persona", persona])

def chat_completion(messages):
    api_key = get_api_key()
    httpProfile = HttpProfile()
    httpProfile.endpoint = "hunyuan.tencentcloudapi.com"

    clientProfile = ClientProfile()
    clientProfile.httpProfile = httpProfile
    client = hunyuan_client.HunyuanClient(api_key, "ap-guangzhou", clientProfile)
    req = models.ChatCompletionsRequest()

    params = {
        "Model": "hunyuan-standard",
        "Messages": messages
    }

    req.from_json_string(json.dumps(params))
    response = client.ChatCompletions(req)

    output = response.Choices[0].Message.Content

    return output


def generate_user_persona(conversions, last_persona):
    # TODO: 讨论一下这个函数怎么调用
    api_key = get_api_key()
    httpProfile = HttpProfile()
    httpProfile.endpoint = "hunyuan.tencentcloudapi.com"

    clientProfile = ClientProfile()
    clientProfile.httpProfile = httpProfile
    client = hunyuan_client.HunyuanClient(api_key, "ap-guangzhou", clientProfile)
    req = models.ChatCompletionsRequest()

    # client = OpenAI(api_key=api_key)

    messages = []
    messages.append({"Role": "user", "Content": Create_User_Prompt.format(conversions=conversions, last_persona=last_persona)})
    # messages.append({"role": "user", "content" : user_input})
    # messages.append({"role": "assistant", "content" : user_output})
    params = {
        "Model": "hunyuan-standard",
        "Messages": messages
    }

    req.from_json_string(json.dumps(params))
    response = client.ChatCompletions(req)
    output = response.Choices[0].Message.Content
    return output


def get_chatbot_persona(user_id, chatbot_id):
    with connection.cursor() as cursor:
        cursor.execute(
            "select chatbot_persona from ChatBot where user_id = %s and chatbot_id = %s",
            [user_id, chatbot_id])
        row = cursor.fetchall()
    if(len(row)==0):
        return None
    return row[0]